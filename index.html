<html>
<head>
<title>Pixie</title>

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:locale" content="en_US" />
<meta property="og:title" content="Pixie: Pixel Art Generator" />
<meta property="og:description" content="Create stunning pixel art and animations with Pixie, a powerful HTML5 Canvas tool. It's a Progressive Web App (PWA) designed for ease of use and offline accessibility." />
<meta name="keywords" content="Pixie, pixel art, pixel art generator, HTML5 canvas, PWA, animation tool,pixel art generator, online pixel art, PWA pixel art tool, create pixel art, pixel art editor, save pixel art, drawing tools, layers, export pixel art" />
<meta name="news_keywords" content="Pixie, pixel art, pixel art generator, HTML5 canvas, PWA, animation tool" />
<meta name="language" content="English">
<meta property="og:url" content="https://github.com/krishn404/Pixie" />
<meta property="og:site_name" content="PixHeart" />
<meta property="article:tag" content="PixHeart" />
<meta property="article:tag" content="pixel art" />

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Pixie Pixel Art Generator">
<meta name="twitter:description" content="Create Simple pixel art online with Pixie">
<meta name="twitter:image" content=" ">

<link rel="shortcut icon" type="image/png" href="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/486f10a4-bc94-4e9d-8c07-e58b91e46c02/dcv3vgp-b93de998-bfbd-417d-afab-65ed881585e1.png/v1/fill/w_1024,h_648/review_bot_pixel_art_by_pieriteyt_dcv3vgp-fullview.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9NjQ4IiwicGF0aCI6IlwvZlwvNDg2ZjEwYTQtYmM5NC00ZTlkLThjMDctZTU4YjkxZTQ2YzAyXC9kY3YzdmdwLWI5M2RlOTk4LWJmYmQtNDE3ZC1hZmFiLTY1ZWQ4ODE1ODVlMS5wbmciLCJ3aWR0aCI6Ijw9MTAyNCJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.apIa9eHa_xx7xalC62hNbUlC2k3MUvMZDp1QhF1mMgw"/>
<link rel="manifest" href="manifest.json">
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-QLjvk5jF11Sp2l7ML9LGPE7tAxQbMYzT5i2M+QUjVOr0djDsZP0wGhF3X9QsS0G3e1jCer4OKjJhJpL1bz7F6Q==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="style.css">
<script src="https://kit.fontawesome.com/473e8f3a80.js" crossorigin="anonymous"></script>
<script src="lib/Matrix.js" async></script>
<script src="lib/Shapes.js" async></script>
<script src="lib/Transformation.js" async></script>
<script src="lib/gif.js"></script>


</head>
<body>
  
  <div class="container-fluid">
    <div class="row">
      <div class="col-2">
        <div class="menubtn">â˜°</div>
        <ul class="menu">
          <li onclick="newProject()">New</li>
          <li onclick="board.save()">Save image</li>
          <li onclick="install()">Install PWA</li>
        </ul>
      </div>
      <div class="col-8">
  <canvas id="canvas"></canvas>
  <div id="toolbar" class=" justify-content-between align-items-center">
    <span class="item" onclick="board.setmode(0)" title="Pencil"><i class="fas fa-pencil-alt"></i></span>
    <span class="item" onclick="board.setmode(1)" title="Eraser"><i class="fas fa-eraser"></i></span>
    <span class="item" onclick="board.setmode(2)" title="Fill"><i class="fas fa-fill"></i></span>
    <span class="item" onclick="board.setmode(3)" title="Line"><i class="fas fa-slash"></i></span>
    <span class="item" onclick="board.setmode(4)" title="Circle"><i class="far fa-circle"></i></span>
    <span class="item" onclick="board.setmode(5)" title="Rotated Circle"><i class="far fa-circle" style="transform: rotateX(45deg);"></i></span>
    <span class="item" onclick="board.addFrame()" title="Add Frame"><i class="fas fa-plus"></i></span>
    <span class="item" onclick="board.undo()" title="Undo"><i class="fas fa-undo"></i></span>
    <span class="item" onclick="board.redo()" title="Redo"><i class="fas fa-redo"></i></span>
    <span class="item" onclick="board.clear()" title="Clear"><i class="fas fa-trash"></i></span>
    <span class="item" onclick="board.addImage()" title="Upload Image"><i class="fa fa-upload"></i></span>
    <span class="item" onclick="Frames.open()" title="View Frames"><i class="fas fa-eye"></i></span>
  </div>
</div>

      <div class="col-2">
        <div id="popup">
          <h3>Select the Dimensions Of the grid</h3>
          <input type="text" id="width" value="16">X<input type="text" id="height" value="16">
          <button id="close" class="btn btn-primary">OK</button>
        </div>
        <div id="frames" tabindex="0">
          <div class="btn" style="left: 10px;" onclick="document.querySelector('#frames #gallery').scrollLeft -= 100;"><i class="fa fa-chevron-left"></i></div>
          <div class="btn" style="right: 10px;" onclick="document.querySelector('#frames #gallery').scrollLeft += 100;"><i class="fa fa-chevron-right"></i></div>
          <div id="gallery"></div>
        </div>
        <div id="palette"></div>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script>
</body>
<script type="text/javascript">
var Tool = {
  "pen": 0,
  "eraser": 1,
  "fillBucket": 2,
  "line": 3,
  "circle": 4,
  "ellipse": 5,
  "addFrame": 6,
  "undo": 7,
  "redo": 8,
  "clearCanvas": 9
};
var tools = [true, false, false, false, false, false];
var lc = [];
class Canvas {
  constructor(width, height) {
    this.canvas = document.querySelector("#canvas");
    this.offscreenCanvas = document.createElement("canvas");
    this.canvas.width = this.offscreenCanvas.width = 10 * width;
    this.canvas.height = this.offscreenCanvas.height = 10 * height;
    this.width = width;
    this.height = height;
    this.canvas.style.display = "block";
    this.canvas.style.height = Math.floor((height / width) * this.canvas.clientWidth) + "px";
    this.w = +this.canvas.width;
    this.h = +this.canvas.height;
    this.ctx = this.canvas.getContext("2d");
    this.offscreenCtx = this.offscreenCanvas.getContext("2d");
    this.offscreenCtx.fillStyle = "white";
    this.offscreenCtx.globalAlpha = 1;
    this.offscreenCtx.fillRect(0, 0, this.w, this.h);
    this.data = [...Array(this.width)].map(e => Array(this.height).fill([255, 255, 255, 255]));
    this.steps = [];
    this.redo_arr = [];
    this.frames = [];
    this.drawGrid();
    this.canvas.addEventListener("click", e => {
      var rect = this.canvas.getBoundingClientRect();
      var x = e.clientX - rect.left;
      var y = e.clientY - rect.top;
      x = Math.floor(this.width * x / this.canvas.clientWidth);
      y = Math.floor(this.height * y / this.canvas.clientHeight);
      if (tools[Tool.fillBucket]) {
        filler(x, y, this.data[x][y]);
      } else if (tools[Tool.eraser]) {
        var temp = this.color;
        var tga = this.offscreenCtx.globalAlpha;
        this.setcolor([255, 255, 255, 255]);
        this.draw(x, y);
        this.setcolor(temp);
        this.offscreenCtx.globalAlpha = tga;
      } else if (tools[Tool.line]) {
        lc.push(new Point(x, y));
        if (lc.length == 2) {
          var lp = line(lc[0], lc[1]);
          lc = [];
          var p;
          for (p of lp) this.draw(p.x, p.y);
        }
      } else if (tools[Tool.circle]) {
        var centre = new Point(x, y);
        var radius = +prompt("radius?");
        var lp = circle(radius, centre);
        var p;
        for (p of lp) this.draw(p.x, p.y);
      } else if (tools[Tool.ellipse]) {
        var center = new Point(x, y);
        var radiusX = +prompt("X radius?");
        var radiusY = +prompt("Y radius?");
        var lp = ellipse(radiusX, radiusY, center);
        for (p of lp)
          this.draw(p.x, p.y);
      } else {
        this.draw(x, y);
      }
    });

    this.canvas.addEventListener("mousemove", e => {
      if (this.active) {
        var rect = this.canvas.getBoundingClientRect();
        var x = e.clientX - rect.left;
        var y = e.clientY - rect.top;
        x = Math.floor(this.width * x / this.canvas.clientWidth);
        y = Math.floor(this.height * y / this.canvas.clientHeight);
        if(tools[Tool.pen]){
          this.draw(x, y)
        }
        else if(tools[Tool.eraser]){
          this.erase(x, y);
        }
      }
    });

    this.canvas.addEventListener("touchmove", e => {
      var rect = this.canvas.getBoundingClientRect();
      var x = e.touches[0].clientX - rect.left;
      var y = e.touches[0].clientY - rect.top;
      x = Math.floor(this.width * x / this.canvas.clientWidth);
      y = Math.floor(this.height * y / this.canvas.clientHeight);
      if(tools[Tool.pen]){
        this.draw(x, y);
      }
      else if(tools[Tool.eraser]){
        this.erase(x, y);
      }
    })

    this.canvas.addEventListener("mousedown", e => {
      this.active = true;
    });
    this.canvas.addEventListener("mouseup", e => {
      this.active = false;
    });
  }

  draw(x, y, count) {
    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
      this.data[x][y] = this.color;
      this.offscreenCtx.fillRect(Math.floor(x * (this.w / this.width)), Math.floor(y * (this.h / this.height)), Math.floor(this.w / this.width), Math.floor(this.h / this.height));
      if (!count && JSON.stringify(this.steps[this.steps.length-1])!==JSON.stringify([x,y,this.color,this.offscreenCtx.globalAlpha])) this.steps.push([x,y,this.color,this.offscreenCtx.globalAlpha]);
      this.render();
    }
  }

  erase(x, y){
    var temp = this.color;
    var tga = this.offscreenCtx.globalAlpha;
    this.setcolor([255, 255, 255, 255]);
    this.draw(x, y);
    this.setcolor(temp);
    this.offscreenCtx.globalAlpha = tga;
  }

  setcolor(color) {
    this.offscreenCtx.globalAlpha = 1;
    this.color = color;
    this.offscreenCtx.fillStyle = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + color[3] + ")";
  }

  setmode(i) {
    tools = [false, false, false, false, false, false];
    tools[i] = true;
    document.querySelectorAll("#toolbar .item").forEach((x, i) => {
      if (tools[i]) x.style.backgroundColor = "grey";
      else x.style.backgroundColor = "";
    })
  }

  save() {
    this.canvas.toBlob(function (blob) {
      var url = URL.createObjectURL(blob);
      var link = document.createElement('a');
      link.download = 'canvas.png';
      link.href = url;
      link.click();
    })
  }

  clear() {
    this.offscreenCtx.fillStyle = "white";
    this.offscreenCtx.fillRect(0, 0, this.w, this.h);
    this.data = [...Array(this.width)].map(e => Array(this.height).fill([255, 255, 255, 255]));
    this.setcolor(this.color);
    this.setmode(Tool.pen);
    this.render();
  }

  addFrame(data=null) {
    var img = new Image();
    img.src = data || this.canvas.toDataURL();
    this.frames.push([img,this.data.map(inner => inner.slice())]);
  }

  deleteFrame(f) {
    this.frames.splice(f,1);
  }

  loadFrame(f) {
    this.clear();
    var img = this.frames[f][1];
    var tmp_color = this.color;
    var tmp_alpha = this.offscreenCtx.globalAlpha;
    this.offscreenCtx.globalAlpha = 1;
    var i,j;
    for (i=0; i<this.width; i++) {
      for (j=0; j<this.height; j++) {
        this.setcolor(img[i][j]);
        this.draw(i,j);
      }
    }
    this.setcolor(tmp_color);
    this.offscreenCtx.globalAlpha = tmp_alpha;
  }

  renderGIF() {
    this.frames.forEach(frame => {
      gif.addFrame(frame[0], {
          copy: true,
          delay: 100
      });
    });
    gif.render();
  }

  undo() {
    this.clear();
    this.redo_arr.push(this.steps.pop());
    var step;
    this.steps.forEach(step => {
      this.setcolor(step[2]);
      this.offscreenCtx.globalAlpha = step[3];
      this.draw(step[0],step[1],true);
    });
  }

  redo() {
    this.steps.push(this.redo_arr.pop());
    var step;
    this.steps.forEach(step => {
      this.setcolor(step[2]);
      this.offscreenCtx.globalAlpha = step[3];
      this.draw(step[0],step[1],true);
    });
  }

  saveInLocal(){
    /*let a = this.frames.map(frame=> [frame[0].src,frame[1]]);
    let f =  JSON.stringify(a);*/
    let d = {
      'colors': window.colors,
      'currColor': this.color,
      'width': this.width,
      'height': this.height,
      'url': this.canvas.toDataURL(),
      'steps': this.steps,
      'redo_arr': this.redo_arr,
      'dim': window.dim,
    }
    localStorage.setItem('pc-canvas-data', JSON.stringify(d));
  }

  addImage() {
  var _this = this;
  var fp = document.createElement("input");
  fp.type = "file";
  fp.click();
  fp.onchange = function(e) {
    var reader = new FileReader();
    reader.readAsDataURL(e.target.files[0]);
    reader.onload = function(event) {
      var uimg = new Image();
      uimg.src = event.target.result;
      uimg.onload = function() {
        var pxctx = document.createElement("canvas").getContext("2d");
        pxctx.canvas.width = _this.w;
        pxctx.canvas.height = _this.h;
        pxctx.drawImage(uimg, 0, 0, _this.w, _this.h);
        
        // Check if the canvas width and height are set properly
        if (_this.w <= 0 || _this.h <= 0) {
          console.error("Canvas width and height must be greater than 0");
          return;
        }

        // Check if getImageData returns a valid object
        try {
          var imgdata = pxctx.getImageData(0, 0, _this.w, _this.h).data;
        } catch (error) {
          console.error("Failed to get image data:", error);
          return;
        }

        var i, j, p;
        for (i = 0; i < _this.w; i += 10) {
          for (j = 0; j < _this.h; j += 10) {
            p = _this.getPixelColor(i, j, imgdata, _this.w, _this.h);
            _this.setcolor(p);
            _this.draw(Math.floor(i / 10), Math.floor(j / 10));
          }
        }
      };

      // Error handling for image loading
      uimg.onerror = function() {
        console.error("Failed to load image");
      };
    };

    // Error handling for file reading
    reader.onerror = function() {
      console.error("Failed to read file");
    };
  };
}

  getPixelColor(x, y, data, width, height) {
    var pIndex = (y*width + x) * 4;
    return [data[pIndex], data[pIndex+1], data[pIndex+2], data[pIndex+3]];
  }

  drawGrid() {
    this.ctx.strokeStyle = "#000000";
    this.ctx.lineWidth = 0.2;
    for (let i = 0; i < this.width; i++) {
      for (let j = 0; j < this.height; j++) {
        this.ctx.strokeRect(i * (this.w / this.width), j * (this.h / this.height), this.w / this.width, this.h / this.height);
      }
    }
  }

  render() {
    this.ctx.clearRect(0, 0, this.w, this.h);
    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
    this.drawGrid();
  }
}
class Popup {
  constructor(s) {
    this.s = s;
    document.querySelector(this.s).style.display = "block";
    document.querySelector(this.s).style.transform = "translate(-50%,-50%) scale(1,1)";
  }
  close() {
    document.querySelector(this.s).style.transform = "translate(-50%,-50%) scale(0,0)";
  }
}

class Frames {
  static open() {
  	document.querySelector("#frames").style.display = "block";
    document.querySelector("#frames").style.transform = "translate(-50%,-50%) scale(1,1)";
    document.querySelector("#frames").focus();
    document.querySelector("#frames #gallery").innerHTML="";
    for (var frame of board.frames) document.querySelector("#frames #gallery").appendChild(frame[0]);
    document.querySelectorAll("#frames #gallery img").forEach((x,i) => {
    	x.onclick = (e) => {
    		board.loadFrame(i);
    		Frames.close();
    	};
    	x.oncontextmenu = (e) => {
    		e.preventDefault();
    		var del_confirmation = confirm("Delete?");
    		if (del_confirmation) {
    			board.deleteFrame(i);
    			Frames.open();
    		}
    	};
    });
  }
  static close() {
    document.querySelector("#frames").style.transform = "translate(-50%,-50%) scale(0,0)";
  }
}

window.onload = function () {
  let canvasData = localStorage.getItem('pc-canvas-data');
  if(canvasData){
    data = JSON.parse(canvasData);
    console.log(data);
    window.colors = data.colors;
    window.board = new Canvas(data.width, data.height);
    let img = new Image();
    img.setAttribute('src', data.url);
    img.addEventListener("load", function () {
        window.board.ctx.drawImage(img, 0, 0);
    });
    /*
    window.board.frames = JSON.parse(data.frames).map(frame=>{
      let img = new Image();
      img.src = frame[0]
      return [img, frame[1]]
    });
    
    for(let f in data.frames){
      let c = document.createElement('canvas');
      c.width = data.width;
      c.height = data.height;
      let c_ctx = c.getContext('2d');
      c_ctx.drawImage(f[0], 0, 0);
      window.board.addFrame(c.toDataURL());
    }
   */ 
    
    window.board.steps = data.steps;
    window.board.redo_arr = data.redo_arr;
    window.board.setcolor(data.currColor);
    window.gif = new GIF({
      workers: 2,
      quality: 10,
      width: 10 * window.board.width,
      height: 10 * window.board.height
    });
    window.gif.on('finished', function (blob) {
      var url = URL.createObjectURL(blob);
      var link = document.createElement('a');
      link.download = 'canvas.gif';
      link.href = url;
      link.click();
    });
  }
  else {
    newProject();
  }
  document.querySelector("#palette").innerHTML = colors.map(x => `<span class="item" style="background-color: rgb(${x[0]},${x[1]},${x[2]})" onclick="board.setcolor([${x}]);act(this);" oncontextmenu="board.setcolor([${x}]);act(this);board.ctx.globalAlpha=+prompt('Transparency(0-1)?')"></span>`).join("\n");

  document.querySelector("#palette").addEventListener("contextmenu",e=>e.preventDefault());
}

document.querySelector("#close").onclick = function () {
  var width = +document.querySelector("#width").value;
  var height = +document.querySelector("#height").value;
  window.board = new Canvas(width, height);
  window.board.setcolor([0, 0, 0, 255]);
  window.dim.close();
  window.gif = new GIF({
    workers: 2,
    quality: 10,
    width: 10 * window.board.width,
    height: 10 * window.board.height
  });
  window.gif.on('finished', function (blob) {
    var url = URL.createObjectURL(blob);
    var link = document.createElement('a');
    link.download = 'canvas.gif';
    link.href = url;
    link.click();
  });
}

document.querySelector(".menubtn").onclick = function () {
  document.querySelector(".menu").style.display = document.querySelector(".menu").style.display != "block" ? "block" : "none";
}

function newProject(){
  document.querySelector(".menu").style.display = "none";
  localStorage.removeItem('pc-canvas-data');
  window.dim = new Popup("#popup");
  window.colors = [
    [0, 0, 0, 255],
    [127, 127, 127, 255],
    [136, 0, 21, 255],
    [237, 28, 36, 255],
    [255, 127, 39, 255],
    [255, 242, 0, 255],
    [34, 177, 36, 255],
    [0, 162, 232, 255],
    [63, 72, 204, 255],
    [163, 73, 164, 255],
    [255, 255, 255, 255],
    [195, 195, 195, 255],
    [185, 122, 87, 255],
    [255, 174, 201, 255],
    [255, 201, 14, 255],
    [239, 228, 176, 255],
    [181, 230, 29, 255],
    [153, 217, 234, 255],
    [112, 146, 190, 255],
    [200, 191, 231, 255]
  ];
}
function filler(x, y, cc) {
  if (x >= 0 && x < board.width && y >= 0 && y < board.height) {
    if (JSON.stringify(board.data[x][y]) == JSON.stringify(cc) && JSON.stringify(board.data[x][y]) != JSON.stringify(board.color)) {
      board.draw(x, y);
      filler(x + 1, y, cc);
      filler(x, y + 1, cc);
      filler(x - 1, y, cc);
      filler(x, y - 1, cc);
    }
  }
}

function act(clr) {
  document.querySelectorAll("#palette .item").forEach(x => x.style.boxShadow = "");
  clr.style.boxShadow = "10px 10px 10px 10px rgba(0,0,0,0.5)";
}

window.onbeforeunload = function () {
  board.saveInLocal();
  return "Data will be lost if you leave the page, are you sure?";
};	

var scope = {
  scope: './'
};
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register(
    'sw.js',
    scope
  ).then(function(serviceWorker) {
    console.log('successful');
  }).catch(function(error) {
    alert("error");
  });
} else {
  console.log('unavailable');
}

var msg;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  msg = e;
});

function install() {
  msg.prompt();
}

window.onerror = function (errorMsg, url, lineNumber) {
  alert('Error: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber);
}
</script>
</html>
